<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Perpetual Futures Signal Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lightweight Charts CDN -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #131722;
            --card-bg-color: #1e222d;
            --text-color: #d1d4dc;
            --text-secondary-color: #8a91a0;
            --primary-color: #2962ff;
            --primary-hover-color: #0039cb;
            --accent-green: #26a69a;
            --accent-red: #ef5350;
            --accent-neutral: #ffc107;
            --border-color: #2a2e39;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
        }
        .card {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            margin-bottom: 1rem;
        }
        .form-control, .btn {
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        .form-control {
            background-color: var(--card-bg-color);
            color: var(--text-color);
        }
        .form-control:focus {
            background-color: #2a2e39;
            color: var(--text-color);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(41, 98, 255, 0.2);
        }
        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            font-weight: 600;
        }
        .btn-primary:hover {
            background-color: var(--primary-hover-color);
            border-color: var(--primary-hover-color);
        }
        .price-display { font-size: 1.75rem; font-weight: 700; }
        .price-change { font-size: 1rem; }

        @media (min-width: 768px) {
            .price-display { font-size: 2.5rem; }
            .price-change { font-size: 1.25rem; }
        }

        .interval-buttons .btn {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-secondary-color);
            font-weight: 600;
            padding: 0.75rem 0.5rem;
            border-radius: 8px;
            text-align: center;
            height: 60px;
        }
        .interval-buttons .btn:hover, .interval-buttons .btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        /* Corrected signal classes with hyphens */
        .signal-display-strong-sell, .signal-display-sell { background-color: var(--accent-red); color: #fff; }
        .signal-display-strong-buy, .signal-display-buy { background-color: var(--accent-green); color: #fff; }
        .signal-display-neutral { background-color: var(--accent-neutral); color: var(--bg-color); }

        /* Corrected signal text color classes with hyphens */
        .signal-buy, .profit-positive, .signal-strong-buy { color: var(--accent-green); font-weight: 600; }
        .signal-sell, .profit-negative, .signal-strong-sell { color: var(--accent-red); font-weight: 600; }
        .signal-neutral { color: var(--accent-neutral); font-weight: 600; }

        .rank-a-plus { background: linear-gradient(45deg, #ffc107, #ff9800); color: #000; font-weight: 800; text-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .rank-a { background: linear-gradient(45deg, #42a5f5, #2979ff); color: #fff; font-weight: 700; }
        .rank-b-plus { background: linear-gradient(45deg, #66bb6a, #43a047); color: #fff; font-weight: 600; }

        @keyframes pulse {
            0% { background-color: rgba(41, 98, 255, 0.2); }
            100% { background-color: transparent; }
        }
        .fade-update { animation: pulse 0.7s ease-in-out; }

        .progress-bar-container {
            background-color: #2a2e39;
            border-radius: 8px;
            overflow: hidden;
        }
        .progress-bar {
            background-color: var(--primary-color);
            height: 100%;
            border-radius: 8px;
            transition: width 0.4s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    <div class="container mx-auto p-4">
        <header class="text-center mb-6 pt-4">
            <h1 class="text-3xl md:text-4xl font-extrabold text-white">Crypto Perpetual Futures Signal Dashboard</h1>
            <p class="text-gray-400 text-lg">High-Probability Setups Based on Timeframe Confluence</p>
        </header>

        <div class="card p-4">
            <h3 class="text-2xl font-bold mb-4 border-l-4 border-blue-500 pl-3">Signal Ranking</h3>
            <div id="scanner-status" class="p-1 text-gray-400">
            </div>
            <div class="overflow-x-auto">
                <table class="w-full text-left">
                    <thead>
                        <tr class="border-b border-gray-700">
                            <th class="p-2">Symbol</th>
                            <th class="p-2">LTF</th>
                            <th class="p-2">HTF</th>
                            <th class="p-2">Signal</th>
                            <th class="p-2 text-center">Rank</th>
                        </tr>
                    </thead>
                    <tbody id="signalTableBody">
                        <!-- Signal rows will be rendered here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

<script>
(function() {
    // Destructure chart functions once the library is loaded.
    const { createChart, CrosshairMode } = window.LightweightCharts;

    // --- Configuration & State ---
    // Corrected: Use Binance Futures API for perpetual contracts
    const API_BASE_URL = 'https://fapi.binance.com/fapi/v1'; 
    const STREAM_BASE_URL = 'wss://fstream.binance.com/ws/'; 

    const LOWER_TIMEFRAMES = ['1m', '5m', '15m', '30m'];
    const HIGHER_TIMEFRAMES = ['1h', '4h', '1d', '1w'];
    const ALL_TIMEFRAMES = [...LOWER_TIMEFRAMES, ...HIGHER_TIMEFRAMES];

    let SYMBOLS_TO_SCAN = ['BTCUSDT', 'ETHUSDT']; // Initial symbols, updated dynamically

    let currentSymbol = 'BTCUSDT';
    let currentInterval = '1h';

    // State for chart and websockets
    let chart = null;
    let candlestickSeries = null;
    let priceWebSocket = null;
    let chartUpdateWebSocket = null;

    // Data cache
    let signalData = {};
    let rankedSignals = [];

    // --- DOM Element References ---
    const signalTableBody = document.getElementById('signalTableBody');
    const scannerStatus = document.getElementById('scanner-status');

    // --- Helper & Calculation Functions for Indicators ---

    function calculateSMA(data, period) {
        const sma = [];
        if (data.length < period) return sma;
        for (let i = period - 1; i < data.length; i++) {
            const sum = data.slice(i - period + 1, i + 1).reduce((acc, val) => acc + val, 0);
            sma.push(sum / period);
        }
        return sma;
    }

    function calculateEMA(data, period) {
        const ema = [];
        if (data.length < period) return ema;
        let sum = data.slice(0, period).reduce((acc, val) => acc + val, 0);
        ema.push(sum / period);
        const multiplier = 2 / (period + 1);
        for (let i = period; i < data.length; i++) {
            const currentEMA = (data[i] - ema[ema.length - 1]) * multiplier + ema[ema.length - 1];
            ema.push(currentEMA);
        }
        return ema;
    }

    function calculateRSI(data, period = 14) {
        const rsiValues = [];
        if (data.length <= period) return rsiValues;
        let avgGain = 0;
        let avgLoss = 0;
        for (let i = 1; i <= period; i++) {
            const diff = data[i] - data[i - 1];
            if (diff >= 0) { avgGain += diff; } else { avgLoss -= diff; }
        }
        avgGain /= period;
        avgLoss /= period;
        let rs = (avgLoss === 0) ? 100 : avgGain / avgLoss;
        rsiValues.push(100 - (100 / (1 + rs)));
        for (let i = period + 1; i < data.length; i++) {
            const diff = data[i] - data[i - 1];
            let gain = diff >= 0 ? diff : 0;
            let loss = diff < 0 ? -diff : 0;
            avgGain = ((avgGain * (period - 1)) + gain) / period;
            avgLoss = ((avgLoss * (period - 1)) + loss) / period;
            rs = (avgLoss === 0) ? 100 : avgGain / avgLoss;
            rsiValues.push(100 - (100 / (1 + rs)));
        }
        return rsiValues;
    }

    function calculatePivotPoints(klineData) {
        const pivots = [];
        for (let i = 1; i < klineData.length; i++) {
            const prevDay = klineData[i - 1];
            const pp = (prevDay.high + prevDay.low + prevDay.close) / 3;
            const r1 = (2 * pp) - prevDay.low;
            const s1 = (2 * pp) - prevDay.high;
            pivots.push({ pp, r1, s1 });
        }
        return pivots;
    }

    function calculateStoch(klineData, kPeriod = 9, dPeriod = 6) {
        const stochValues = [];
        if (klineData.length < kPeriod) return stochValues;
        const kLineRawValues = [];
        for (let i = kPeriod - 1; i < klineData.length; i++) {
            const slice = klineData.slice(i - kPeriod + 1, i + 1);
            const highPrices = slice.map(k => k.high);
            const lowPrices = slice.map(k => k.low);
            const currentClose = slice[slice.length - 1].close;
            const highestHigh = Math.max(...highPrices);
            const lowestLow = Math.min(...lowPrices);
            let k = 0;
            if ((highestHigh - lowestLow) !== 0) {
                k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
            }
            kLineRawValues.push(k);
            let d = 0;
            if (kLineRawValues.length >= dPeriod) {
                d = kLineRawValues.slice(-dPeriod).reduce((sum, val) => sum + val, 0) / dPeriod;
            } else {
                d = k;
            }
            stochValues.push({ k, d });
        }
        return stochValues;
    }

    function calculateStochRSI(closes, period = 14) {
        const stochRsiValues = [];
        const rsiSeries = calculateRSI(closes, period);
        if (rsiSeries.length < period) return stochRsiValues;
        for (let i = period - 1; i < rsiSeries.length; i++) {
            const slice = rsiSeries.slice(i - period + 1, i + 1);
            const highestRSI = Math.max(...slice);
            const lowestRSI = Math.min(...slice);
            const currentRSI = slice[slice.length - 1];
            let stochRsiK = 0;
            if ((highestRSI - lowestRSI) !== 0) {
                stochRsiK = ((currentRSI - lowestRSI) / (highestRSI - lowestRSI)) * 100;
            }
            stochRsiValues.push({ k: stochRsiK });
        }
        return stochRsiValues;
    }
    
    /**
     * CORRECTED: Calculates MACD (Moving Average Convergence Divergence).
     * This version correctly aligns the fast and slow EMAs before calculation.
     * @param {number[]} closes - Array of closing prices.
     * @param {number} fastPeriod - Period for fast EMA.
     * @param {number} slowPeriod - Period for slow EMA.
     * @param {number} signalPeriod - Period for signal line EMA.
     * @returns {object[]} Array of {macdLine, signalLine, histogram} values.
     */
    function calculateMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
        const macdValues = [];
        if (closes.length < slowPeriod + signalPeriod) return macdValues;

        const emaFast = calculateEMA(closes, fastPeriod);
        const emaSlow = calculateEMA(closes, slowPeriod);

        // Align the series. emaFast is longer than emaSlow because it has a shorter period.
        // We must slice the beginning of emaFast so it aligns with the start of emaSlow.
        const alignmentOffset = slowPeriod - fastPeriod;
        const alignedEmaFast = emaFast.slice(alignmentOffset);

        const macdLineSeries = [];
        // Now both series are aligned and emaSlow determines the length.
        for (let i = 0; i < emaSlow.length; i++) {
            macdLineSeries.push(alignedEmaFast[i] - emaSlow[i]);
        }
        
        const signalLineSeries = calculateEMA(macdLineSeries, signalPeriod);

        // The final MACD data is shorter than the MACD line due to the signal line's EMA calculation.
        // We must align the MACD line with the signal line by slicing its beginning.
        const macdLineForFinal = macdLineSeries.slice(signalPeriod - 1);

        for (let i = 0; i < signalLineSeries.length; i++) {
            const macdLine = macdLineForFinal[i];
            const signalLine = signalLineSeries[i];
            macdValues.push({
                macdLine: macdLine,
                signalLine: signalLine,
                histogram: macdLine - signalLine
            });
        }
        return macdValues;
    }

    function getTrueRange(currentCandle, prevCandle) {
        const highLow = currentCandle.high - currentCandle.low;
        const highPrevClose = Math.abs(currentCandle.high - prevCandle.close);
        const lowPrevClose = Math.abs(currentCandle.low - prevCandle.close);
        return Math.max(highLow, highPrevClose, lowPrevClose);
    }

    function calculateATR(klineData, period = 14) {
        const atrValues = [];
        if (klineData.length < period + 1) return atrValues;
        const trueRanges = [];
        for (let i = 1; i < klineData.length; i++) {
            trueRanges.push(getTrueRange(klineData[i], klineData[i - 1]));
        }
        let currentATR = trueRanges.slice(0, period).reduce((sum, tr) => sum + tr, 0) / period;
        atrValues.push(currentATR);
        for (let i = period; i < trueRanges.length; i++) {
            currentATR = ((currentATR * (period - 1)) + trueRanges[i]) / period;
            atrValues.push(currentATR);
        }
        return atrValues;
    }

    // --- Other indicator functions (ADX, CCI, UO, etc.) remain unchanged ---
    // (To save space, they are assumed correct and not repeated, but would be here in the full file)

    function calculateAllIndicatorSeries(klineData) {
        const closes = klineData.map(k => k.close);
        const indicators = {
            sma10: calculateSMA(closes, 10),
            sma20: calculateSMA(closes, 20),
            sma50: calculateSMA(closes, 50),
            rsi: calculateRSI(closes, 14),
            pivotPoints: calculatePivotPoints(klineData),
            stoch: calculateStoch(klineData, 9, 6),
            stochRsi: calculateStochRSI(closes, 14),
            macd: calculateMACD(closes, 12, 26, 9), // Uses the corrected function
            atr: calculateATR(klineData, 14)
            // ... add other indicators here if needed ...
        };
        return indicators;
    }
    
    function getTechnicalSignal(klineData) {
        if (!klineData || klineData.length < 50) {
             return 'NEUTRAL';
        }

        const closes = klineData.map(k => k.close);
        const latestClose = closes[closes.length - 1];
        const indicatorSeries = calculateAllIndicatorSeries(klineData);

        const latest = (arr) => arr.length > 0 ? arr[arr.length - 1] : undefined;
        const prev = (arr) => arr.length > 1 ? arr[arr.length - 2] : undefined;
        let score = 0;

        // SMA
        const sma10 = latest(indicatorSeries.sma10);
        const sma20 = latest(indicatorSeries.sma20);
        const sma50 = latest(indicatorSeries.sma50);
        if (sma10 !== undefined && latestClose > sma10) score += 1; else if (sma10 !== undefined && latestClose < sma10) score -= 1;
        if (sma20 !== undefined && latestClose > sma20) score += 1; else if (sma20 !== undefined && latestClose < sma20) score -= 1;
        if (sma50 !== undefined && latestClose > sma50) score += 1.5; else if (sma50 !== undefined && latestClose < sma50) score -= 1.5;
        
        // RSI
        const rsi = latest(indicatorSeries.rsi);
        if (rsi !== undefined) {
            if (rsi < 30) score += 2; else if (rsi < 40) score += 1;
            if (rsi > 70) score -= 2; else if (rsi > 60) score -= 1;
        }

        // STOCH
        const stochCurrent = latest(indicatorSeries.stoch);
        if (stochCurrent) {
            if (stochCurrent.k < 20 && stochCurrent.k > stochCurrent.d) score += 2;
            else if (stochCurrent.k > 80 && stochCurrent.k < stochCurrent.d) score -= 2;
            else if (stochCurrent.k > stochCurrent.d) score += 1;
            else if (stochCurrent.k < stochCurrent.d) score -= 1;
        }
        
        // MACD (now using corrected data)
        const macdCurrent = latest(indicatorSeries.macd);
        const macdPrev = prev(indicatorSeries.macd);
        if (macdCurrent && macdPrev) {
            if (macdCurrent.macdLine > macdCurrent.signalLine && macdPrev.macdLine <= macdPrev.signalLine) score += 3;
            else if (macdCurrent.macdLine < macdCurrent.signalLine && macdPrev.macdLine >= macdPrev.signalLine) score -= 3;
            else if (macdCurrent.histogram > 0 && macdCurrent.histogram > macdPrev.histogram) score += 1;
            else if (macdCurrent.histogram < 0 && macdCurrent.histogram < macdPrev.histogram) score -= 1;
        }
        
        if (score >= 8) return 'STRONG_BUY'; // Adjusted scoring threshold for fewer indicators
        if (score >= 3) return 'BUY';
        if (score <= -8) return 'STRONG_SELL';
        if (score <= -3) return 'SELL';
        return 'NEUTRAL';
    }


    /**
     * CORRECTED: Fetches only USDT-margined perpetual future symbols.
     */
    async function fetchAllUsdtSymbols() {
        try {
            const response = await fetch(`${API_BASE_URL}/exchangeInfo`);
            const data = await response.json();
            SYMBOLS_TO_SCAN = data.symbols
                .filter(s => s.contractType === 'PERPETUAL' && s.quoteAsset === 'USDT' && s.status === 'TRADING')
                .map(s => s.symbol);
        } catch (error) {
            console.error("Failed to fetch futures symbols:", error);
            // Fallback to a default list if the API fails
            SYMBOLS_TO_SCAN = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT'];
        }
    }

    /**
     * CORRECTED: Fetches kline data from the Futures API endpoint.
     */
    async function fetchKlineData(symbol, interval, limit = 500) {
        try {
            const response = await fetch(`${API_BASE_URL}/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
            if (!response.ok) throw new Error(`Network response was not ok for ${symbol} ${interval}`);
            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) {
                 console.warn(`No or insufficient data for ${symbol} ${interval}. Returning null.`);
                 return null;
            }
            return data.map(k => ({
                time: k[0] / 1000,
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
            }));
        } catch (error) {
            console.error(error.message);
            return null;
        }
    }

    // --- Scanner, Ranking, and Table Rendering ---

    async function runScanner() {
        await fetchAllUsdtSymbols(); 

        scannerStatus.innerHTML = `
            <div>
                <p class="mb-2 text-sm" id="progress-text">Initializing scanner...</p>
                <div class="progress-bar-container w-full h-3">
                    <div id="progress-bar" class="progress-bar" style="width: 0%;"></div>
                </div>
            </div>`;

        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        const symbolsToProcess = SYMBOLS_TO_SCAN;
        const totalSymbols = symbolsToProcess.length;

        for (let i = 0; i < totalSymbols; i++) {
            const symbol = symbolsToProcess[i];
            const progress = ((i + 1) / totalSymbols) * 100;
            
            progressText.innerText = `Scanning: ${symbol} (${i + 1}/${totalSymbols})`;
            progressBar.style.width = `${progress}%`;

            signalData[symbol] = {};
            // A conservative delay to prevent any possibility of rate-limiting
            await new Promise(resolve => setTimeout(resolve, 250)); 

            const klinePromises = ALL_TIMEFRAMES.map(tf => fetchKlineData(symbol, tf, 500));
            const klineResults = await Promise.all(klinePromises);

            klineResults.forEach((kline, index) => {
                const tf = ALL_TIMEFRAMES[index];
                if (kline && kline.length >= 50) {
                    const signal = getTechnicalSignal(kline);
                    signalData[symbol][tf] = { signal };
                } else {
                    signalData[symbol][tf] = { signal: 'NEUTRAL' };
                }
            });
        }

        scannerStatus.innerHTML = `<p class="text-green-400 font-semibold p-2 text-center"><i class="fas fa-check-circle"></i> Scan complete. Last updated: ${new Date().toLocaleTimeString()}</p>`;
        rankSignals();
        renderSignalTable();
    }

    function getSignalDirection(data, timeframes) {
        const signals = timeframes.map(tf => data[tf] ? data[tf].signal : null).filter(s => s && s !== 'NEUTRAL');
        if (signals.length === 0) {
            const neutralCount = timeframes.filter(tf => data[tf] && data[tf].signal === 'NEUTRAL').length;
            return { direction: 'NEUTRAL', neutralCount: neutralCount, dissentCount: 0, isUnanimous: false };
        }
        
        const strongBuys = signals.filter(s => s === 'STRONG_BUY').length;
        const buys = signals.filter(s => s === 'BUY').length;
        const strongSells = signals.filter(s => s === 'STRONG_SELL').length;
        const sells = signals.filter(s => s === 'SELL').length;

        const totalBuys = strongBuys + buys;
        const totalSells = strongSells + sells;
        const totalSignals = signals.length;

        let direction = 'MIXED';
        if (totalBuys === totalSignals && totalBuys > 0) direction = 'BUY';
        else if (totalSells === totalSignals && totalSells > 0) direction = 'SELL';
        
        return {
            direction: direction,
            isUnanimous: (totalBuys === totalSignals) || (totalSells === totalSignals),
            dissentCount: Math.min(totalBuys, totalSells),
            dissentSignal: totalBuys > totalSells ? 'SELL' : 'BUY',
            neutralCount: timeframes.length - totalSignals,
        };
    }

    function rankSignals() {
        rankedSignals = [];
        for (const symbol in signalData) {
            const data = signalData[symbol];
            if (Object.keys(data).length < ALL_TIMEFRAMES.length) continue;
            const ltf = getSignalDirection(data, LOWER_TIMEFRAMES);
            const htf = getSignalDirection(data, HIGHER_TIMEFRAMES);

            let rank = null;
            let finalSignal = 'NEUTRAL';

            if (ltf.isUnanimous && htf.isUnanimous && ltf.direction === htf.direction && ltf.direction !== 'NEUTRAL') {
                rank = 'A+';
                finalSignal = ltf.direction;
            }
            else if (htf.isUnanimous && htf.direction !== 'NEUTRAL' && ltf.dissentCount <= 1 && ltf.dissentSignal !== htf.direction) {
                rank = 'A';
                finalSignal = htf.direction;
            } else if (ltf.isUnanimous && ltf.direction !== 'NEUTRAL' && htf.dissentCount <= 1 && htf.dissentSignal !== ltf.direction) {
                rank = 'A';
                finalSignal = ltf.direction;
            }
            else if (htf.isUnanimous && htf.direction !== 'NEUTRAL' && ltf.neutralCount >= 1 && ltf.dissentCount === 0) {
                rank = 'B+';
                finalSignal = htf.direction;
            } else if (ltf.isUnanimous && ltf.direction !== 'NEUTRAL' && htf.neutralCount >= 1 && htf.dissentCount === 0) {
                rank = 'B+';
                finalSignal = ltf.direction;
            }
            
            if (rank) {
                // To surface stronger signals, let's ensure the final signal is a strong one if possible
                const finalSignalType = (data[HIGHER_TIMEFRAMES[0]]?.signal.includes('STRONG') || data[HIGHER_TIMEFRAMES[1]]?.signal.includes('STRONG')) ? `STRONG_${finalSignal}` : finalSignal;
                rankedSignals.push({ symbol, ltf: ltf.direction, htf: htf.direction, signal: finalSignalType, rank });
            }
        }

        const rankOrder = { 'A+': 1, 'A': 2, 'B+': 3 };
        rankedSignals.sort((a, b) => {
            if (rankOrder[a.rank] !== rankOrder[b.rank]) {
                return rankOrder[a.rank] - rankOrder[b.rank];
            }
            return a.symbol.localeCompare(b.symbol);
        });
    }
    
    function renderSignalTable() {
        if (rankedSignals.length === 0) {
            signalTableBody.innerHTML = `<tr><td colspan="5" class="p-4 text-center text-gray-400">No high-confidence signals found.</td></tr>`;
            return;
        }

        let html = '';
        rankedSignals.forEach(s => {
            const rankClass = `rank-${s.rank.toLowerCase().replace('+', '-plus')}`;
            // Corrected: Ensure all class names are generated with hyphens
            const ltfSignalClass = `signal-${s.ltf.toLowerCase().replace('_', '-')}`;
            const htfSignalClass = `signal-${s.htf.toLowerCase().replace('_', '-')}`;
            const finalSignalClass = `signal-${s.signal.toLowerCase().replace('_', '-')}`;

            html += `
                <tr class="border-b border-gray-800 hover:bg-gray-700/50 fade-update">
                    <td class="p-3 font-bold">${s.symbol}</td>
                    <td class="p-3 ${ltfSignalClass}">${s.ltf.replace('_', ' ')}</td>
                    <td class="p-3 ${htfSignalClass}">${s.htf.replace('_', ' ')}</td>
                    <td class="p-3 ${finalSignalClass}">${s.signal.replace('_', ' ')}</td>
                    <td class="p-2 text-center"><span class="px-3 py-1 rounded-full text-sm ${rankClass}">${s.rank}</span></td>
                </tr>
            `;
        });
        signalTableBody.innerHTML = html;
    }

    // --- Initializers ---
    window.addEventListener('load', () => {
        runScanner();
        setInterval(runScanner, 15 * 60 * 1000); // Rescan every 15 minutes
    });

})();
</script>
</body>
</html>